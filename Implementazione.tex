% ================================ L'IMPLEMENTAZIONE ====================================

\chapter{L'implementazione}

%TODO: Implementazione in C++
%TODO: Con gui e command line o solo gui.

%TODO: Volendo anche Java?

%TODO: Presenterò/Mostrerò due implementazioni una fatta specificamente per questo progetto in C++ e un'altra in Java che avevo fatto per altri progetti.
%TODO: Quella in C++ sarà più completa rispetto di quella in Java.

% =======================================================================================

% ---------------------------- SECTION: INTRODUZIONE ------------------------------------

\section{Introduzione}

\textsf{\small } %TODO: In questo capitolo, presenterò due implementazioni, una elaborata esclusivamente per questo progetto in C++ e un'altra in Java che avevo creato per altri progetti universitari. Quella in C++ risulterà più completa rispetto a quella in Java.

% ---------------------------- SECTION: IMPLEMENTAZIONE IN C++ --------------------------

\section{Implementazione in C++}

\textsf{\small } %TODO: Ho adottato C++23 per questo progetto. In esso sono presenti una interfaccia grafica e una applicazione da linea di comando, entrambe hanno le stesse operazioni.

%TODO: Inanzittutto, esibirò, le funzioni riguardanti la matematica di Galois di cui mi sono avvalso.

\subsection{Matematica di Galois}

\textsf{\small } %TODO: Riguardo alla matematica nel campo di Galois, ho adoperato tre funzioni: una che implementa l'addizione e la sottrazione e due per la moltiplicazione.

\textsf{\small Nel campo di Galois, sia l'addizione che la sottrazione sono semplicemente un'operazione di XOR. Questa funzione prende due parametri x ed y di tipo \emph{uint8\_t} (che corrisponde a un \emph{unsigned char}) e restituisce lo XOR tra essi.}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/galois_math/galois_addition_subtraction.PNG}
	\caption{Addizione e sottrazione nel campo di Galois}
	\label{fig:galois_addition_subtraction}
\end{figure}

\textsf{\small \emph{galois\_multiplication()} prende due \emph{uint8\_t} come parametri e restituisce la moltiplicazione tra questi nel campo di Galois.}

\textsf{\emph{static constexpr} indicano che la funzione può essere eseguita a compile time. \emph{noexcept} indica che la funziona non lancia eccezioni. \emph{[[nodiscard]]} indica che il risultato che viene restituito non può essere ignorato, ma deve essere utilizzato.}

%TODO: Aggiungere reference alla parte nel capitolo della Matematica o aggiungere breve spiegazione.

\textsf{\small Facciamo un loop su ogni bit del byte e verifichiamo se il secondo valore \emph{y} ha il bit meno significativo attivo (y \& 0x01) allora aggiungiamo \emph{x} (ovvero eseguiamo uno XOR) al risultato. Dopodiché verifichiamo se il bit più significativo \emph{high\_bit} è attivo in \emph{x}. Poi ruotiamo x di 1. Se l'\emph{high\_bit} è \emph{true} eseguiamo uno XOR tra x e il polinomio irriducibile \emph{IRREDUCIBLE\_POLYNOMIAL}, ovvero $0x1\text{B}$. Infine ruotiamo il secondo valore di 1 per ruotarlo a destra. Poi restituiamo il risultato finale delle operazioni.}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/galois_math/galois_multiplication.PNG}
	\caption{Moltiplicazione nel campo di Galois}
	\label{fig:galois_multiplication}
\end{figure}

\textsf{\small \emph{xtime(const uint8\_t\& x)} prende un numero in input e restituisce la round constant.} %TODO:

\textsf{\small Questa funzione è utilizzata per generare la round constant.}
\textsf{\small L'algoritmo di questa funzione è il seguente: }

\begin{itemize}
	\item \textsf{\small il round\_constant(1) = 1.}
	\item \textsf{\small round\_constant(i) = $2 \cdot \text{round\_constant}(i - 1) \text{se round\_constant(i - 1) < 0x80}$}
	\item \textsf{\small round\_constant($2 \cdot \text{round\_constant(i - 1)}$) $ \oplus \hspace{0.3mm} \text{0x11B } \ge 0x80$ }
\end{itemize}

\begin{figure}[H] %TODO: update.
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/galois_math/xtime.PNG}
	\caption{Generatrice delle costanti di round}
	\label{fig:xtime}
\end{figure}

%TODO: Come prima cosa mostrerò l'implementazione dell'algoritmo di AES con tutte le varie operazioni all'interno di ogni round di AES, ovvero: add round key, sub bytes, shift rows e mix columns. Dopodiché presenterò la parte di Key Expansion, ovvero come vengono ottenute le chiavi per ogni round, anch'esso composto da queste fasi: rot word, sub word, rcon.

%\subsection{Cifratura} %TODO: uncomment?

\subsection{Add Round Key}

\textsf{\small Nella fase di \emph{add\_round\_key()} la chiave di round viene aggiunta alla matrice di stato.}

\textsf{\small La funzione prende la matrice di stato 4x4 (formata da due std::array di grandezza BLOCK\_WORDS che indica il numero di words in un blocco, ovvero 4) e la chiave del round come puntatore e le aggiunge.}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/encryption/add_round_key.PNG}
	\caption{Add Round Key}
	\label{fig:add_round_key}
\end{figure}

\subsection{Sub Bytes}

\textsf{\small Nella funzione \emph{sub\_bytes} ogni byte della matrice di stato viene sostituito con quelli presenti nella S-BOX.}

\textsf{\small Quindi, nella funzione viene passata la matrice di stato come reference, quindi tutti le modifiche verranno applicate anche all'esterno della funzione e poi viene eseguito un loop e ogni elemento viene sostituito con il corrispettivo della S-BOX.}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/encryption/sub_bytes.PNG}
	\caption{Sub Bytes}
	\label{fig:sub_bytes}
\end{figure}

\subsection{Shift Rows}

\textsf{\small Nel passaggio di \emph{shift rows} le righe della matrice di stato verranno \emph{shiftate} di una posizione la seconda riga, di due posizione la terza e di tre la quarta.}

\textsf{\small Per fare questo ci avvaliamo di due funzioni, una \emph{shift\_row} per shiftare effettivamente le righe e nell'altra \emph{shift\_rows} per chiamare la precedente funzione per shiftare delle posizioni stabilite.}

%TODO: aggiungere altro?

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/encryption/shift_row.PNG}
	\caption{Shift Row}
	\label{fig:shift_row}
\end{figure}

\textsf{\small } %TODO:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/encryption/shift_rows.PNG}
	\caption{Shift Rows}
	\label{fig:shift_rows}
\end{figure}

\subsection{Mix Columns}

\textsf{\small La procedura \emph{mix\_columns} prende in input la matrice di stato, mescola i suoi bytes.} %TODO:

%TODO: Aggiungere altro.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/encryption/mix_columns.PNG}
	\caption{Mix Columns}
	\label{fig:mix_columns}
\end{figure}

%TODO: funzioni di decifrazione?

\subsection{Key Expansion}

\textsf{\small In questa funzione vengono generate le altre chiavi dei rounds a partire dalla prima chiave. Gli viene passata un array con la chiave, una word e la tipologia di AES: 128, 192 o 256.} %TODO:

\textsf{\small Dopodiché eseguiamo le operazioni di: \emph{rot\_word}, \emph{sub\_word}, e \emph{rcon}. Dopodiché viene eseguito uno XOR tra la chiave e il rcon. Dopodiché si continua a eseguire uno XOR con le chiavi precedenti.}

%TODO: Aggiungere altro.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/key_expansion/key_expansion.PNG}
	\caption{Key Expansion}
	\label{fig:key_expansion_code}
\end{figure}

\subsubsection{Rot Word}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/key_expansion/rot_word.PNG}
	\caption{Rot Word}
	\label{fig:rot_word}
\end{figure}

\textsf{\small In questa operazione ogni byte (word di 32 bits, ovvero 4 bytes) viene ruotato di 1 posizione.} %TODO: Aggiungere altro.

\subsubsection{Sub Word}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/key_expansion/sub_word.PNG}
	\caption{Sub Word}
	\label{fig:sub_word}
\end{figure}

\textsf{\small Nella procedura \emph{sub\_word()} ogni byte della chiave viene sostituita con quella della S-BOX.} %TODO:

\subsubsection{Rcon}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/key_expansion/rcon.PNG}
	\caption{Rcon}
	\label{fig:rcon}
\end{figure}

\textsf{\small Nella funzione \emph{rcon}, le \emph{round constants} vengono generate attraverso una funzione ricorsiva.} %TODO:

\subsubsection{Xor Blocks} %TODO: uncomment?

\textsf{\small Con questa funzione eseguiamo uno XOR per ogni bit \emph{i} tra i blocchi x e y e assegniamo il risultato a ogni bit del blocco z. }

\textsf{\small Il loop viene eseguito in base alla grandezza del blocco.}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/key_expansion/xor_blocks.PNG}
	\caption{Xor Blocks}
	\label{fig:xor_blocks}
\end{figure}

%\textsf{\small } %TODO:

\subsection{Modes}

\textsf{\small } %TODO:

%TODO: subsection: Modes con codice? Questo si potrebbe fare.

\subsubsection{ECB}

\textsf{\small ECB è la modalità più semplice e anche quella che non dovrebbe mai essere usata.} %TODO: aggiungere reference alla spiegazione della modalità.

\textsf{\small In questa modalità, semplicemente, ogni blocco viene cifrato com'è. Nessun vettore di inizializzazione viene utilizzato. Lo stesso input genererà lo stesso identico output.}

\textsf{\small Questa modalità inoltre accetta solo blocchi divisibili per 16, questo viene garantito attraverso la funzione \emph{verify\_length()} che verifica e lancia un'eccezione altrimenti.}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/modes/encrypt_ECB.PNG}
	\caption{Cifratura ECB}
	\label{fig:encrypt_ECB}
\end{figure}

\textsf{\small Per la decifrazione è lo stesso procedimento, ma inverso. } %TODO:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/modes/decrypt_ECB.PNG}
	\caption{Decifrazione ECB}
	\label{fig:decrypt_ECB}
\end{figure}

\subsubsection{CBC}

\textsf{\small } %TODO:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/modes/encrypt_CBC.PNG}
	\caption{Cifratura CBC}
	\label{fig:encrypt_CBC}
\end{figure}

\textsf{\small } %TODO:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/modes/decrypt_CBC.PNG}
	\caption{Decifrazione CBC}
	\label{fig:decrypt_CBC}
\end{figure}

\subsubsection{CFB}

\textsf{\small } %TODO:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/modes/encrypt_CFB.PNG}
	\caption{Cifratura CFB}
	\label{fig:encrypt_CFB}
\end{figure}

\textsf{\small }

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/modes/decrypt_CFB.PNG}
	\caption{Decifrazione CFB}
	\label{fig:decrypt_CFB}
\end{figure}

\subsection{Paddings}

\textsf{\small } %TODO:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/padding/add_padding0.PNG}
	\caption{Aggiunta del padding (1/2)}
	\label{fig:add_padding0}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/padding/add_padding1.PNG}
	\caption{Aggiunta del padding (2/2)}
	\label{fig:add_padding1}
\end{figure}

\textsf{\small }

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/padding/remove_padding0.PNG}
	\caption{Rimozione del padding (1/2)}
	\label{fig:remove_padding0}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/padding/remove_padding1.PNG}
	\caption{Rimozione del padding (2/2)}
	\label{fig:remove_padding1}
\end{figure}

\textsf{\small } %TODO:

\subsection{API}

\textsf{\small }

%TODO: solo encrypt e decrypt?

\subsubsection{Cifratura}

\textsf{\small }

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/api/encrypt.PNG}
	\caption{Cifratura}
	\label{fig:encrypt}
\end{figure}

\subsubsection{Decifratura}

\textsf{\small }

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/cpp/api/decrypt.PNG}
	\caption{Decifratura}
	\label{fig:decrypt}
\end{figure}

\textsf{\small } %TODO:

% ---------------------------- SECTION: IMPLEMENTAZIONE IN JAVA -------------------------

\section{Implementazione in Java}

\textsf{\small } %TODO: 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/java/constructor_and_member_variables.PNG}
	\caption{Costruttore e variabili membre}
	\label{fig:constructor_and_member_variables}
\end{figure}

\textsf{\small } %TODO: 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/java/nonce_getRandomBytes.PNG}
	\caption{Nonce}
	\label{fig:nonce_getRandomBytes}
\end{figure}

\textsf{\small } %TODO: 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/java/getKeyFromPassword.PNG}
	\caption{Password}
	\label{fig:getKeyFromPassword}
\end{figure}

\textsf{\small } %TODO: 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/java/encrypt.PNG}
	\caption{Cifratura}
	\label{fig:encrypt_java}
\end{figure}

\textsf{\small } %TODO: 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/java/decrypt.PNG}
	\caption{Decifratura}
	\label{fig:decrypt_java}
\end{figure}

\textsf{\small } %TODO: 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/java/encryptFile.PNG}
	\caption{Funziona per la cifratura di un File}
	\label{fig:encryptFile}
\end{figure}

\textsf{\small } %TODO: 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./images/code/java/decryptFile.PNG}
	\caption{Funziona per la decifrazione di un File}
	\label{fig:decryptFile}
\end{figure}

\textsf{\small } %TODO: 

% -------------------------------- FINE CAPITOLO ----------------------------------------